# MiniKernel OS 架构总览

## 1. 项目简介

MiniKernel OS 是一个从零开始构建的微内核操作系统项目，基于 x86_64 架构实现。本项目旨在提供一个清晰、模块化、易于理解的操作系统内核实现，遵循现代微内核设计原则。

### 1.1 设计目标

- **最小化内核**：内核仅负责最核心的功能
- **模块化设计**：各组件高度解耦，便于独立开发和测试
- **可移植性**：架构相关代码与通用代码分离
- **教育目的**：代码清晰易读，适合操作系统学习者研究

### 1.2 核心特性

| 特性 | 描述 |
|------|------|
| 虚拟内存 | 4级页表支持的 x86_64 虚拟内存管理 |
| 进程调度 | 基于 CFS（完全公平调度器）的调度算法 |
| 内存分配 | 伙伴系统（Buddy System）物理页面分配 |
| 同步原语 | 自旋锁、读写锁等内核同步机制 |
| 中断处理 | 完整的 IDT 配置与中断/异常处理框架 |

---

## 2. 系统架构

### 2.1 整体架构图

```
┌─────────────────────────────────────────────────────────────────────┐
│                         用户空间 (User Space)                        │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐            │
│  │   init   │  │   vfsd   │  │   netd   │  │   devd   │   用户程序  │
│  │  (PID 1) │  │  (VFS)   │  │  (网络)   │  │  (设备)  │            │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘  └────┬─────┘            │
│       │             │             │             │                   │
│       └─────────────┴─────────────┴─────────────┘                   │
│                            │ IPC / 系统调用                          │
├────────────────────────────┼────────────────────────────────────────┤
│                     系统调用接口 (syscall)                           │
├─────────────────────────────────────────────────────────────────────┤
│                         内核空间 (Kernel)                            │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                        微内核核心                             │   │
│  │                                                              │   │
│  │  ┌───────────────┐  ┌───────────────┐  ┌───────────────┐    │   │
│  │  │   进程调度器   │  │   内存管理器   │  │   IPC 核心    │    │   │
│  │  │  (CFS/RT/DL)  │  │ (Buddy/VMM)   │  │              │    │   │
│  │  └───────────────┘  └───────────────┘  └───────────────┘    │   │
│  │                                                              │   │
│  │  ┌───────────────┐  ┌───────────────┐  ┌───────────────┐    │   │
│  │  │   中断处理器   │  │   同步原语    │  │   时钟管理    │    │   │
│  │  │  (IDT/IRQ)    │  │ (Spinlock/RW) │  │   (Jiffies)  │    │   │
│  │  └───────────────┘  └───────────────┘  └───────────────┘    │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
├─────────────────────────────────────────────────────────────────────┤
│                      硬件抽象层 (HAL / Arch)                         │
│                                                                     │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐           │
│  │  Boot    │  │  页表    │  │ GDT/IDT  │  │ 上下文    │           │
│  │  引导    │  │  管理    │  │  管理    │  │  切换     │           │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘           │
└─────────────────────────────────────────────────────────────────────┘
                                  │
                                  ▼
┌─────────────────────────────────────────────────────────────────────┐
│                              硬件                                    │
│       CPU   •   内存   •   磁盘   •   网卡   •   键盘   •   显示器   │
└─────────────────────────────────────────────────────────────────────┘
```

### 2.2 分层架构原理

MiniKernel 采用经典的分层架构设计：

1. **硬件层**：物理硬件设备
2. **HAL 层**：硬件抽象层，隔离架构差异
3. **内核核心层**：提供核心操作系统服务
4. **系统调用层**：用户空间与内核空间的接口
5. **用户空间层**：用户态服务和应用程序

这种分层设计的优势：
- **隔离性**：每层只与相邻层交互，降低耦合度
- **可移植性**：更换硬件平台只需修改 HAL 层
- **可维护性**：各层职责明确，便于调试和升级

---

## 3. 目录结构

```
minikernel/
├── arch/                       # 架构相关代码
│   └── x86_64/
│       ├── boot/               # 引导代码、链接脚本
│       │   ├── boot.S          # 多启动引导程序
│       │   └── kernel.ld       # 内核链接脚本
│       ├── cpu/                # CPU 特定代码
│       │   └── switch.S        # 上下文切换
│       └── mm/                 # 架构相关内存管理
│
├── kernel/                     # 内核核心代码
│   ├── core/                   # 微内核核心模块
│   │   ├── process/            # 进程管理
│   │   ├── thread/             # 线程管理
│   │   ├── sched/              # 调度器
│   │   │   ├── sched.c         # 调度器核心
│   │   │   └── sched_fair.c    # CFS 实现
│   │   └── ipc/                # 进程间通信
│   ├── include/                # 内核头文件
│   │   ├── types.h             # 基础类型定义
│   │   ├── sched.h             # 调度器头文件
│   │   ├── mm.h                # 内存管理头文件
│   │   ├── list.h              # 双向链表
│   │   └── spinlock.h          # 自旋锁
│   ├── interrupt/              # 中断处理框架
│   │   └── interrupt.S         # 中断处理汇编
│   ├── mm/                     # 内存管理
│   │   └── buddy.c             # 伙伴系统分配器
│   └── drivers/                # 内核态驱动
│
├── include/                    # 公共头文件（兼容层）
│
├── src/                        # 主要源代码
│   ├── kernel/
│   │   ├── main.c              # 内核入口
│   │   └── shell.c             # 调试 Shell
│   └── mm/
│
├── user/                       # 用户态组件
│   ├── services/               # 用户态服务
│   │   ├── init/               # 初始化进程
│   │   ├── vfsd/               # VFS 服务
│   │   ├── netd/               # 网络服务
│   │   └── devd/               # 设备管理服务
│   ├── apps/                   # 用户程序
│   └── libs/                   # 用户态库
│
├── tests/                      # 测试代码
├── tools/                      # 构建工具
├── scripts/                    # 自动化脚本
├── docs/                       # 文档
│   ├── architecture/           # 架构文档
│   ├── kernel/                 # 内核文档
│   ├── subsystems/             # 子系统文档
│   └── api/                    # API 文档
│
├── Makefile                    # 主构建文件
├── meson.build                 # Meson 构建配置
└── conanfile.py                # Conan 依赖管理
```

---

## 4. 核心组件概述

### 4.1 引导系统 (Boot)

引导系统负责将 CPU 从实模式/保护模式切换到 64 位长模式，并初始化基本的运行环境。

**关键功能**：
- Multiboot/Multiboot2 协议支持
- 设置临时页表（映射前 1GB）
- 启用分页和长模式
- 跳转到内核主函数

**相关文件**：`arch/x86_64/boot/boot.S`, `arch/x86_64/boot/kernel.ld`

### 4.2 内存管理 (Memory Management)

内存管理子系统包含物理内存分配和虚拟内存管理两大部分。

**关键功能**：
- 伙伴系统物理页面分配器
- 4级页表虚拟地址映射
- 内存区域管理（DMA、Normal、HighMem）

**相关文件**：`kernel/mm/buddy.c`, `kernel/include/mm.h`

### 4.3 进程调度 (Scheduler)

调度器采用模块化设计，支持多种调度策略。

**调度类**：
- `fair_sched_class`：CFS 公平调度
- `rt_sched_class`：实时调度（FIFO/RR）
- `idle_sched_class`：空闲调度

**相关文件**：`kernel/core/sched/sched.c`, `kernel/core/sched/sched_fair.c`

### 4.4 中断处理 (Interrupt)

中断处理框架负责管理 CPU 异常和外部中断。

**关键功能**：
- IDT（中断描述符表）管理
- 异常处理（除零、页错误等）
- IRQ 处理（时钟、键盘等）
- 系统调用入口

**相关文件**：`kernel/interrupt/interrupt.S`

### 4.5 上下文切换 (Context Switch)

上下文切换是调度器的核心机制，负责保存/恢复进程状态。

**保存的状态**：
- 通用寄存器（RAX, RBX, RCX, RDX, RSI, RDI, R8-R15）
- 栈指针（RSP, RBP）
- 标志寄存器（RFLAGS）
- 浮点/SIMD 状态（可选）

**相关文件**：`arch/x86_64/cpu/switch.S`

---

## 5. 内存布局

### 5.1 虚拟地址空间布局

```
0xFFFFFFFF FFFFFFFF ┌────────────────────┐
                    │   内核保留区域      │
0xFFFFFFFF 80000000 ├────────────────────┤
                    │   内核模块          │
0xFFFFFFFF 00000000 ├────────────────────┤
                    │   vmalloc 区域      │
0xFFFF8880 00000000 ├────────────────────┤
                    │   直接映射区域      │
                    │ (物理内存映射)      │
0xFFFF8000 00000000 ├────────────────────┤ KERNEL_VIRTUAL_BASE
                    │                    │
                    │   空洞              │
                    │ (规范地址边界)      │
                    │                    │
0x00007FFF FFFFFFFF ├────────────────────┤
                    │   用户栈           │
                    │      ↓             │
                    │                    │
                    │      ↑             │
                    │   mmap 区域        │
                    │      ↑             │
                    │   堆 (brk)         │
                    │                    │
                    │   BSS 段           │
                    │   Data 段          │
                    │   Text 段          │
0x00000000 00400000 ├────────────────────┤
                    │   保留区域          │
0x00000000 00000000 └────────────────────┘
```

### 5.2 物理内存布局

```
物理地址              描述
──────────────────────────────────
0x00000000 - 0x000FFFFF   低端内存（1MB）
0x00100000 - 0x001FFFFF   内核加载区域（1MB 开始）
0x00200000 - ...          可用内存
```

---

## 6. 启动流程

### 6.1 启动序列

```
┌────────────────┐
│   BIOS/UEFI   │
└───────┬────────┘
        │ 加载 Bootloader
        ▼
┌────────────────┐
│  Multiboot2   │
│  (GRUB/QEMU)  │
└───────┬────────┘
        │ 加载内核到 0x100000
        ▼
┌────────────────┐
│   boot.S      │  (32位保护模式)
│   _start      │
└───────┬────────┘
        │ 检查 CPUID、长模式支持
        │ 设置页表、启用分页
        │ 切换到长模式
        ▼
┌────────────────┐
│   boot.S      │  (64位长模式)
│ long_mode_start│
└───────┬────────┘
        │ 设置段寄存器、栈
        │ 调用 kernel_main()
        ▼
┌────────────────┐
│   main.c      │
│  kernel_main  │
└───────┬────────┘
        │ kernel_init()
        ▼
┌────────────────┐
│  初始化子系统   │
│  mm_init()    │
│  sched_init() │
│  ...          │
└───────┬────────┘
        │ 创建 init 进程
        │ 启动 shell
        ▼
┌────────────────┐
│   shell_run() │
│  用户交互      │
└────────────────┘
```

### 6.2 初始化顺序

1. **内存管理初始化** (`mm_init`, `buddy_init`)
   - 初始化伙伴系统分配器
   - 设置内存区域

2. **调度器初始化** (`sched_init`)
   - 初始化运行队列
   - 设置调度类

3. **IPC 初始化** (`ipc_init`)
   - 初始化消息传递机制

4. **VFS 初始化** (`vfs_init`)
   - 初始化虚拟文件系统

5. **网络初始化** (`net_init`)
   - 初始化网络协议栈

6. **驱动初始化** (`driver_init`)
   - 初始化设备驱动

7. **创建 init 进程**
   - PID 1，系统第一个用户态进程

---

## 7. 调度模型

### 7.1 调度类层次

```
┌─────────────────────────────────────┐
│          调度器核心 (schedule)       │
└─────────────────┬───────────────────┘
                  │
    ┌─────────────┼─────────────┐
    ▼             ▼             ▼
┌────────┐  ┌────────────┐  ┌────────┐
│ Stop   │→ │ Deadline   │→ │  RT    │
│ Class  │  │   Class    │  │ Class  │
└────────┘  └────────────┘  └───┬────┘
                                │
                          ┌─────┴─────┐
                          ▼           ▼
                     ┌────────┐  ┌────────┐
                     │  Fair  │→ │  Idle  │
                     │ (CFS)  │  │ Class  │
                     └────────┘  └────────┘
```

### 7.2 CFS 调度原理

CFS (Completely Fair Scheduler) 的核心思想是维护每个任务的"虚拟运行时间"（vruntime），并始终选择 vruntime 最小的任务运行。

**关键数据结构**：
- **红黑树**：按 vruntime 排序存储可运行任务
- **min_vruntime**：运行队列的最小虚拟运行时间

**时间片计算**：
```
                    task_weight
time_slice = ────────────────────── × sched_period
              total_runqueue_weight
```

**vruntime 更新**：
```
                      NICE_0_LOAD
vruntime += delta × ──────────────
                      task_weight
```

---

## 8. 同步机制

### 8.1 自旋锁 (Spinlock)

自旋锁是最基本的同步原语，适用于短期临界区。

**实现原理**：
```c
void spin_lock(spinlock_t *lock) {
    while (!CAS(&lock->lock, UNLOCKED, LOCKED)) {
        while (lock->lock == LOCKED) {
            cpu_relax();  // 降低总线压力
        }
    }
}
```

### 8.2 读写锁 (RWLock)

读写锁允许多个读者同时访问，但写者独占。

**状态转换**：
```
         读锁请求
    ┌────────────┐
    │            ▼
┌───┴───┐   ┌─────────┐
│ 空闲  │   │ 读锁定  │
└───┬───┘   └────┬────┘
    │            │
    │ 写锁请求    │ 写锁请求（阻塞）
    ▼            │
┌─────────┐      │
│ 写锁定  │◄─────┘
└─────────┘
```

---

## 9. 系统调用

### 9.1 系统调用入口

系统调用通过 `syscall` 指令进入内核，入口点在 `interrupt.S` 中的 `syscall_entry`。

**调用约定** (x86_64 System V ABI)：
- `RAX`：系统调用号
- `RDI`, `RSI`, `RDX`, `R10`, `R8`, `R9`：参数 1-6
- `RAX`：返回值

### 9.2 支持的系统调用

| 编号 | 名称 | 描述 |
|------|------|------|
| 0 | read | 读取文件 |
| 1 | write | 写入文件 |
| 2 | open | 打开文件 |
| 3 | close | 关闭文件 |
| 39 | getpid | 获取进程 ID |
| 57 | fork | 创建子进程 |
| 59 | execve | 执行程序 |
| 60 | exit | 退出进程 |

---

## 10. 构建系统

### 10.1 构建工具

项目支持两种构建方式：

1. **Makefile**（传统方式）
2. **Meson + Conan**（推荐方式）

### 10.2 构建流程

```
源代码 (.c, .S)
      │
      ▼ 编译
目标文件 (.o)
      │
      ▼ 链接 (kernel.ld)
ELF 文件 (kernel.elf)
      │
      ▼ objcopy
二进制文件 (kernel.bin)
      │
      ▼ grub-mkrescue (可选)
ISO 镜像 (kernel.iso)
```

---

## 11. 相关文档

- [内核启动流程](01-boot-process.md)
- [内存管理详解](../subsystems/memory-management.md)
- [进程调度详解](../subsystems/scheduler.md)
- [中断处理详解](../subsystems/interrupts.md)
- [系统调用参考](../api/syscalls.md)

---

## 12. 参考资料

- [OSDev Wiki](https://wiki.osdev.org/)
- [Intel® 64 and IA-32 Architectures Software Developer Manuals](https://software.intel.com/content/www/us/en/develop/articles/intel-sdm.html)
- [Linux Kernel Source](https://www.kernel.org/)
- [seL4 Microkernel](https://sel4.systems/)